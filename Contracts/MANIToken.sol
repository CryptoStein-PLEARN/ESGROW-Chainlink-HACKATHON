// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;

//@deployed contract 0x00fFD3548725459255f1e78A61A07f1539Db0271

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "./interfaces/IMani.sol";

contract MANI is IMani, ERC20, KeeperCompatibleInterface {
    address private voteContract;
    address private superAdmin;
    address[] registeredAddresses;
    uint registerationTimeFrame;
    uint registerationStartTime;
    mapping(address => bool) public registered;
    bool private locked;
    uint totalAirDrop;

    enum State {
        PRE_REGISTERATION,
        REGISTERING,
        AIRDROPPING,
        DONE
    }

    State state;

    modifier lock() {
        require(!locked, "already airdropped");
        _;
    }

    modifier onlySuperAdmin() {
        require(_msgSender() == superAdmin, "not authorized");
        _;
    }

    constructor(uint _registerationTimeFrame) ERC20("MANIFESTATION", "MANI") {
        _mint(msg.sender, 2 ether);
        state = State.PRE_REGISTERATION;
        registerationTimeFrame = _registerationTimeFrame;
        superAdmin = _msgSender();
    }

    function register() external returns (bool) {
        require(voteContract != address(0), "registeration not opened");
        require(state == State.REGISTERING, "registeration closed");
        require(!registered[_msgSender()], "you already registered");
        registeredAddresses.push(_msgSender());
        registered[_msgSender()] = true;
        approve(voteContract, 2 ether);
        return true;
    }

    function setVoteContract(address voteContractAddress)
        external
        onlySuperAdmin
    {
        voteContract = voteContractAddress;
        registerationStartTime = block.timestamp;
        state = State.REGISTERING;
    }

    function airDropUsers() private lock {
        require(state == State.AIRDROPPING, "not airdropping currently");
        for (uint i = 0; i < registeredAddresses.length; ) {
            _mint(registeredAddresses[i], 2 ether);
            totalAirDrop += 2 ether;
            unchecked {
                ++i;
            }
        }
        locked = true;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        if (state == State.REGISTERING) {
            upkeepNeeded =
                (block.timestamp - registerationStartTime) >
                registerationTimeFrame;
            performData = abi.encode("mani");
            // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
        }
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if (
            (block.timestamp - registerationStartTime) > registerationTimeFrame
        ) {
            state = State.AIRDROPPING;
            airDropUsers();
            state = State.DONE;
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function withdrawTokens() external onlySuperAdmin {
        uint contractBalance = balanceOf(address(this));
        transfer(superAdmin, contractBalance);
    }

    function setSuperAdmin(address admin) external onlySuperAdmin {
        superAdmin = admin;
    }

    function getState() external view onlySuperAdmin returns (State) {
        return state;
    }

    function getRegisteredAddresses()
        external
        view
        override
        returns (address[] memory)
    {
        return registeredAddresses;
    }

    function getTotalNumberOfAirdrop()
        external
        view
        onlySuperAdmin
        returns (uint)
    {
        return totalAirDrop;
    }

    function manuallyStartAirDrop() external onlySuperAdmin {
        require(state == State.REGISTERING, "not registering");
        state = State.AIRDROPPING;
        airDropUsers();
        state = State.DONE;
    }
}
