// SPDX-License-Identifier: MIT
pragma solidity ^0.8.1;


import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

contract MANI is ERC20, KeeperCompatibleInterface{

address private voteContract;
address private superAdmin;
address[] registeredAddresses;
uint registerationTimeFrame;
uint registerationStartTime;
mapping(address => bool) registered;
bool private locked;

enum State {PRE_REGISTERATION,REGISTERING, AIRDROPPING, DONE}

State state;

modifier lock(){
    require(!locked,"already airdropped");
    locked = true;
    _;
}


modifier onlySuperAdmin{
    require(_msgSender()== superAdmin,"not authorized");
    _;
}
    constructor(uint _registerationTimeFrame) ERC20("MANIFESTATION", "MANI") {
        _mint(msg.sender, 160000000 ether);
        state = State.PRE_REGISTERATION;
        registerationTimeFrame = _registerationTimeFrame;
    }
    
    function register() external returns(bool){
       require(voteContract!=address(0),"registeration not opened");
       require(state == State.REGISTERING,"registeration closed");
       require(!registered[_msgSender()],"you already registered");
       registeredAddresses.push(_msgSender());
       registered[_msgSender()] = true;
       approve(voteContract,2 ether);
       return true;
    }

   
    function setVoteContract(address voteContractAddress) external onlySuperAdmin{
       voteContract = voteContractAddress;
       registerationStartTime = block.timestamp;
       state = State.REGISTERING;
    }

   
   function airDropUsers() private lock {
       require(state == State.AIRDROPPING,"not airdropping currently");
       for(uint i = 0; i<registeredAddresses.length;){
       _mint(registeredAddresses[i],2 ether);
           unchecked{
               ++i;
           }
       }
       locked = true;
   }
   
    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory performData ) {
        upkeepNeeded = (block.timestamp - registerationStartTime) > registerationTimeFrame;
        performData = abi.encode("hi");
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - registerationStartTime) > registerationTimeFrame ) {
            state = State.AIRDROPPING;
            airDropUsers();
            state = State.DONE;
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }


}

